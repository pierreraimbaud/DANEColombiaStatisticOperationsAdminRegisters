<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

.cell {
  fill: none;
  stroke: grey;
}
#chart {
        display: inline-block;
        float: left;
      }

      #chartDetail {
        display: inline-block;
        float: right;
      }
.p.letters {
    word-wrap: break-word;
     width:auto;
     white-space:normal
}
</style>
<body>
<input id="checkGroupInABox" type="checkbox">Group in a Box</input>
<input id="checkShowTreemap" type="checkbox">Show Template</input>
  <select id="selectTemplate" type="select">
    <option value="treemap">Treemap</option>
    <option value="force">Force</option>
  </select>
      <div id='container'>

        <div id = "chart">
        </div>
<div id = "chartDetail">
              <p style="color:#709410;font-size:105%"; word-wrap="break-word";
     width="auto";-ms-word-break="break-all";-webkit-hyphens="auto";
       -moz-hyphens="auto";
        -ms-hyphens="auto";
            hyphens="auto";
     white-space="normal";word-break="break-all"; align="center">xxxxxxxxxx</p>
              
              <p style="font-size:65%""font-weight:bold">name</p>
              <p id='name' style="font-size:65%"; align="left";>Details</p>
              <p style="font-size:65%" "align:left" "font-weight:bold">type</p>
              <p id='type' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%" "align:left" "font-weight:bold">statisticalOperations</p>
              <p id='statisticalOperations' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%" "align:left" "font-weight:bold">objective</p>
              <p id='objective' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%" "align:left" "font-weight:bold">unityObservation</p>
              <p id='unityObservation' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%" "align:left" "font-weight:bold">entitiesUsing</p>
              <p id='entitiesUsing' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%" "align:left" "font-weight:bold">variables</p>
              <p id='variables' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">daneDependency</p>
              <p id='daneDependency' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">thematic</p>
              <p id='thematic' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">thematic2</p>
              <p id='thematic2' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">thematicShared</p>
              <p id='thematicShared' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">entityProducing</p>
              <p id='entityProducing' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">periodicity</p>
              <p id='periodicity' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">geographicZone</p>
              <p id='geographicZone' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">geographicDivision</p>
              <p id='geographicDivision' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">indicators</p>
              <p id='indicators' style="font-size:65%"; align="left">Details</p>
              <p style="font-size:65%"; align="left">methodologyOOEE</p>
              <p id='methodologyOOEE' style="font-size:65%"; align="left">Details</p>
        </div>
</div>
<script src="//d3js.org/d3.v4.js"></script>
<script type="text/javascript">
  /* global d3 */

function forceInABox(alpha) {
  function index(d) {
    return d.index;
  }

  var id = index,
      nodes,
      links, //needed for the force version
      tree,
      size = [100,100],
      nodeSize = 1, // The expected node size used for computing the cluster node
      forceCharge = -2,
      foci = {},
      // oldStart = force.start,
      linkStrengthIntraCluster = 0.1,
      linkStrengthInterCluster = 0.01,
      // oldGravity = force.gravity(),
      templateNodes = [],
      offset = [0,0],
      templateForce,
      templateNodesSel,
      groupBy = function (d) { return d.cluster; },
      template = "treemap",
      enableGrouping = true,
      strength = 0.1;
      // showingTemplate = false;


  function force(alpha) {
    if (!enableGrouping) {
      return force;
    }
    if (template==="force") {
      //Do the tick of the template force and get the new focis
      templateForce.tick();
      getFocisFromTemplate();
    }

    for (var i = 0, n = nodes.length, node, k = alpha * strength; i < n; ++i) {
      node = nodes[i];
      node.vx += (foci[groupBy(node)].x - node.x) * k;
      node.vy += (foci[groupBy(node)].y - node.y) * k;
    }

  }

  function initialize() {
    if (!nodes) return;

    // var i,
    //     n = nodes.length,
    //     m = links.length,
    //     nodeById = map(nodes, id),
    //     link;

    if (template==="treemap") {
      initializeWithTreemap();
    } else {
      initializeWithForce();
    }


  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  function getLinkKey(l) {
    var sourceID = groupBy(l.source),
      targetID = groupBy(l.target);

    return sourceID <= targetID ?
      sourceID + "~" + targetID :
      targetID + "~" + sourceID;
  }

  function computeClustersNodeCounts(nodes) {
    var clustersCounts = d3.map();

    nodes.forEach(function (d) {
      if (!clustersCounts.has(groupBy(d))) {
        clustersCounts.set(groupBy(d), 0);
      }
    });

    nodes.forEach(function (d) {
      // if (!d.show) { return; }
      clustersCounts.set(groupBy(d), clustersCounts.get(groupBy(d)) + 1);
    });

    return clustersCounts;
  }

  //Returns
  function computeClustersLinkCounts(links) {
    var dClusterLinks =  d3.map(),
      clusterLinks = [];
    links.forEach(function (l) {
      var key = getLinkKey(l), count;
      if (dClusterLinks.has(key)) {
        count = dClusterLinks.get(key);
      } else {
        count = 0;
      }
      count += 1;
      dClusterLinks.set(key, count);
    });

    dClusterLinks.entries().forEach(function (d) {
      var source, target;
      source = d.key.split("~")[0];
      target = d.key.split("~")[1];
      if (source !== undefined && target !== undefined) {
        clusterLinks.push({
          "source":source,
          "target":target,
          "count":d.value,
        });
      }
    });
    return clusterLinks;
  }

  //Returns the metagraph of the clusters
  function getGroupsGraph() {
    var gnodes = [],
      glinks = [],
      // edges = [],
      dNodes = d3.map(),
      // totalSize = 0,
      clustersList,
      c, i, size,
      clustersCounts,
      clustersLinks;

    clustersCounts = computeClustersNodeCounts(nodes);
    clustersLinks = computeClustersLinkCounts(links);

    //map.keys() is really slow, it's crucial to have it outside the loop
    clustersList = clustersCounts.keys();
    for (i = 0; i< clustersList.length ; i+=1) {
      c = clustersList[i];
      size = clustersCounts.get(c);
      gnodes.push({id : c, size :size });
      dNodes.set(c, i);
      // totalSize += size;
    }

    clustersLinks.forEach(function (l) {
      source = dNodes.get(l.source);
      target = dNodes.get(l.target);
      if (source!==undefined && target !== undefined) {
        glinks.push({
          "source": source,
          "target": target,
          "count":l.count
        });
      } else {
        console.log("Force in a box error, couldn't find the link source or target on the list of nodes");
      }
    });


    return {nodes: gnodes, links: glinks};
  }


  function getGroupsTree() {
    var children = [],
      totalSize = 0,
      clustersList,
      c, i, size, clustersCounts;

    clustersCounts = computeClustersNodeCounts(force.nodes());

    //map.keys() is really slow, it's crucial to have it outside the loop
    clustersList = clustersCounts.keys();
    for (i = 0; i< clustersList.length ; i+=1) {
      c = clustersList[i];
      size = clustersCounts.get(c);
      children.push({id : c, size :size });
      totalSize += size;
    }
    // return {id: "clustersTree", size: totalSize, children : children};
    return {id: "clustersTree",  children : children};
  }


  function getFocisFromTemplate() {
    //compute foci
    foci.none = {x : 0, y : 0};
    templateNodes.forEach(function (d) {
      if (template==="treemap") {
        foci[d.data.id] = {
          x : (d.x0 + (d.x1-d.x0) / 2) - offset[0],
          y : (d.y0 + (d.y1-d.y0) / 2) - offset[1]
        };
      } else {
        foci[d.id] = {x : d.x - offset[0] , y : d.y - offset[1]};
      }
    });
  }
  function initializeWithTreemap() {
    var treemap = d3.treemap()
      .size(force.size());

    tree = d3.hierarchy(getGroupsTree())
      // .sort(function (p, q) { return d3.ascending(p.size, q.size); })
      // .count()
      .sum(function (d) { return d.size; })
      .sort(function(a, b) {
        return b.height - a.height || b.value - a.value; })
      ;


    templateNodes = treemap(tree).leaves();

    getFocisFromTemplate();
  }

  function checkLinksAsObjects() {
    // Check if links come in the format of indexes instead of objects
    var linkCount = 0;
    if (nodes.length===0) return;

    links.forEach(function (link) {
      var source, target;
      if (!nodes) return;
      source = link.source;
      target = link.target;
      if (typeof link.source !== "object") source = nodes[link.source];
      if (typeof link.target !== "object") target = nodes[link.target];
      if (source === undefined || target === undefined) {
        console.log(link);
        throw Error("Error setting links, couldn't find nodes for a link (see it on the console)" );
      }
      link.source = source; link.target = target;
      link.index = linkCount++;
    });
  }

  function initializeWithForce() {
    var net;

    if (nodes && nodes.length>0) {
      if (groupBy(nodes[0])===undefined) {
        throw Error("Couldn't find the grouping attribute for the nodes. Make sure to set it up with forceInABox.groupBy('attr') before calling .links()");
      }
    }

    checkLinksAsObjects();

    net = getGroupsGraph();
    templateForce = d3.forceSimulation(net.nodes)
      .force("x", d3.forceX(size[0]/2).strength(0.5))
      .force("y", d3.forceY(size[1]/2).strength(0.5))
      .force("collide", d3.forceCollide(function (d) { return d.size*nodeSize; }))
      .force("charge", d3.forceManyBody().strength(function (d) { return forceCharge * d.size; }))
      .force("links", d3.forceLink(!net.nodes ? net.links :[]));

    templateNodes = templateForce.nodes();

    getFocisFromTemplate();
  }


  function drawTreemap(container) {
    container.selectAll(".cell").remove();
    container.selectAll("cell")
      .data(templateNodes)
      .enter().append("svg:rect")
      .attr("class", "cell")
      .attr("x", function (d) { return d.x0; })
      .attr("y", function (d) { return d.y0; })
      .attr("width", function (d) { return d.x1-d.x0; })
      .attr("height", function (d) { return d.y1-d.y0; });

  }

  function drawGraph(container) {
    container.selectAll(".cell").remove();
    templateNodesSel = container.selectAll("cell")
      .data(templateNodes);
    templateNodesSel
      .enter().append("svg:circle")
      .attr("class", "cell")
      .attr("cx", function (d) { return d.x; })
      .attr("cy", function (d) { return d.y; })
      .attr("r", function (d) { return d.size*nodeSize; });

  }

  force.drawTemplate = function (container) {
    // showingTemplate = true;
    if (template === "treemap") {
      drawTreemap(container);
    } else {
      drawGraph(container);
    }
    return force;
  };

  //Backwards compatibility
  force.drawTreemap = force.drawTemplate;

  force.deleteTemplate = function (container) {
    // showingTemplate = false;
    container.selectAll(".cell").remove();

    return force;
  };


  force.template = function (x) {
    if (!arguments.length) return template;
    template = x;
    initialize();
    return force;
  };

  force.groupBy = function (x) {
    if (!arguments.length) return groupBy;
    if (typeof x === "string") {
      groupBy = function (d) {return d[x]; };
      return force;
    }
    groupBy = x;
    return force;
  };


  force.enableGrouping = function (x) {
    if (!arguments.length) return enableGrouping;
    enableGrouping = x;
    // update();
    return force;
  };

  force.strength = function (x) {
    if (!arguments.length) return strength;
    strength = x;
    return force;
  };


  force.getLinkStrength = function (e) {
    if(enableGrouping)  {
      if (groupBy(e.source) === groupBy(e.target)) {
        if (typeof(linkStrengthIntraCluster)==="function") {
          return linkStrengthIntraCluster(e);
        } else {
          return linkStrengthIntraCluster;
        }
      } else {
        if (typeof(linkStrengthInterCluster)==="function") {
          return linkStrengthInterCluster(e);
        } else {
          return linkStrengthInterCluster;
        }
      }
    } else {
      // Not grouping return the intracluster
      if (typeof(linkStrengthIntraCluster)==="function") {
          return linkStrengthIntraCluster(e);
        } else {
          return linkStrengthIntraCluster;
        }

    }
  };


  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.size = function(_) {
    return arguments.length ? (size = _, force) : size;
  };

  force.linkStrengthInterCluster = function(_) {
    return arguments.length ? (linkStrengthInterCluster = _, force) : linkStrengthInterCluster;
  };

  force.linkStrengthIntraCluster = function(_) {
    return arguments.length ? (linkStrengthIntraCluster = _, force) : linkStrengthIntraCluster;
  };

  force.nodes = function(_) {
    return arguments.length ? (nodes = _, force) : nodes;
  };

  force.links = function(_) {
    if (!arguments.length)
      return links;
    if (_ === null) links = [];
    else links = _;
    return force;
  };

  force.nodeSize = function(_) {
    return arguments.length ? (nodeSize = _, force) : nodeSize;
  };

  force.forceCharge = function(_) {
    return arguments.length ? (forceCharge = _, force) : forceCharge;
  };

  force.offset = function(_) {
    return arguments.length ? (offset = _, force) : offset;
  };

  return force;
}

  var width = 1000,
    height = 600;

/* global d3, forceInABox */
var svg2 = d3.select("#chartDetail").
        append("svg")
    .attr("width", 250)
    .attr("height", height);

var useGroupInABox = true,
  drawTemplate = true,
  template = "treemap";

d3.select("#checkGroupInABox").property("checked", useGroupInABox);
d3.select("#checkShowTreemap").property("checked", drawTemplate);
d3.select("#selectTemplate").property("value", template);



var color = d3.scaleOrdinal(d3.schemeCategory20);

var force = d3.forceSimulation()
    .force("charge", d3.forceManyBody())
    .force("x", d3.forceX(width/2).strength(0.30))
    .force("y", d3.forceY(height/2).strength(0.30));

var svg = d3.select("#chart")
          .append("svg")
    .attr("width", width)
    .attr("height", height);

d3.json("https://raw.githubusercontent.com/pierreraimbaud/DANEColombiaStatisticOperationsAdminRegisters/master/data/data.json", function(error, graph) {
  var groupingForce = forceInABox()
          .strength(0.1) // Strength to foci
          .template(template) // Either treemap or force
          .groupBy("group") // Node attribute to group
          .links(graph.links) // The graph links. Must be called after setting the grouping attribute
          .enableGrouping(useGroupInABox)
          .nodeSize(5) // How big are the nodes to compute the force template
          .forceCharge(-200) // Separation between nodes on the force template
          .size([width, height]) // Size of the chart
  force
      .nodes(graph.nodes)
      .force("group", groupingForce)
      .force('collision',d3.forceCollide().radius(function(d) { 
              return 12; }))
      .force("link", d3.forceLink(graph.links)
        .distance(80)
        .strength(groupingForce.getLinkStrength)
      );

  force.force("group").drawTemplate(svg);

// Set up dictionary of neighbors
var node2neighbors = {};
for (var i =0; i < graph.nodes.length; i++){
  var id = graph.nodes[i].name;
  node2neighbors[id] = graph.links.filter(function(d){
      return d.source.name == name || d.target.name == name;
    }).map(function(d){
      return d.source.name == name ? d.target.name : d.source.name;
    });
}

  var link = svg.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", function(d){ return ["link", d.source.id, d.target.id].join(" "); })
     // .style("opacity", 0)
      .style("stroke-width", function(d) { return Math.sqrt(d.value); });

  var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("class", "node")
      .attr("id", function(n){ return n.name; })
    //  .style("visibility",function (d) { 
      //        return d.main ==="true" ? true : "hidden";
        //    })
        .style("stroke-width", function(d) { return d.type ==="RRAA" ? 2 : 0; })
                .style("stroke", function(d) { return d.type ==="RRAA" ? "black":""; })
      .attr("r", function (d) { 
              return d.main ==="false" ? 5 : 10;
            })
      .style("fill", function(d) { return color(d.group); })
      .on("click", function(n){
        d3.select("#name").text(n.name);
        d3.select("#type").text(n.type);
        d3.select("#statisticalOperations").text(n.statisticalOperations);
        d3.select("#objective").text(n.objective);
        d3.select("#unityObservation").text(n.unityObservation);
        d3.select("#entitiesUsing").text(n.entitiesUsing);
        d3.select("#variables").text(n.variables);
        d3.select("#daneDependency").text(n.daneDependency);
        d3.select("#thematic").text(n.thematic);
        d3.select("#thematic2").text(n.thematic2);
        d3.select("#thematicShared").text(n.thematicShared);
        d3.select("#entityProducing").text(n.entityProducing);
        d3.select("#periodicity").text(n.periodicity);
        d3.select("#geographicZone").text(n.geographicZone);
        d3.select("#geographicDivision").text(n.geographicDivision);
        d3.select("#indicators").text(n.indicators);
        d3.select("#methodologyOOEE").text(n.methodologyOOEE);

          // Determine if current node's neighbors and their links are visible
       /* var active   = n.active ? false : true // toggle whether node is active
        , newOpacity = 1;

        // Extract node's name and the names of its neighbors
        var id     = n.name
        , neighbors  = node2neighbors[id];

        // Hide the neighbors and their links
        for (var i = 0; i < neighbors.length; i++){
            d3.selectAll("circle#\\" + neighbors[i]).style("visibility", true);
            d3.selectAll("line.\\" + neighbors[i]).style("opacity", newOpacity);
        }
        // Update whether or not the node is active
        n.active = active;
    */
      })
      .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

const label = svg.selectAll("label")
            .data(graph.nodes)
            .enter()
            .append("text")
            .text(function (d) { 
      //!isSvg1 ? d.groups : (d.main ==="true" ? (!isSvg1 ? d.groups : d.group):"") })
                return d.main ==="true" ? d.name :""})//(getStrongestGroupForANode (d, d.groups))[0]}) //d.group})//
            .style("fill", "#2B1513")
            .style("font-weight", d=>d.main ==="true" ? "bold" : "normal")
            .attr("x", d =>d.x)
            .attr("y",d => d.y)
            .style("font-family", "Arial")
            .style("font-size", d=>d.main ==="true" ? 10: 7);

  node.append("title")
      .text(function(d) { return d.name; });

  force.on("tick", function() {
    //link.attr("x1", function(d) { return d.source.x; })
      ///   .attr("y1", function(d) { return d.source.y; })
        // .attr("x2", function(d) { return d.target.x; })
         //.attr("y2", function(d) { return d.target.y; });
label .attr("x", d => d.x)
              .attr("y", d => d.y);
    node.attr("cx", function(d) { return d.x = Math.max(7, Math.min(width - 7, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(7, Math.min(height - 7, d.y)); });
  });

  d3.select("#checkGroupInABox").on("change", function () {
    force.stop();
    useGroupInABox = d3.select("#checkGroupInABox").property("checked");
    force
        // .force("link", d3.forceLink(graph.links).distance(50).strength(
        // function (l) { return !useGroupInABox? 0.7 :
        //     l.source.group!==l.target.group ? 0 : 0.1;
        // }))
        .force("group").enableGrouping(useGroupInABox)

    force.alphaTarget(0.5).restart();
  });

  d3.select("#selectTemplate").on("change", function () {
    template = d3.select("#selectTemplate").property("value");
    force.stop();
    force.force("group").template(template);
    force.alphaTarget(0.5).restart();
  });

  d3.select("#checkShowTreemap").on("change", function () {
    drawTemplate = d3.select("#checkShowTreemap").property("checked");
    if (drawTemplate) {
      force.force("group").drawTemplate(svg);
    } else {
      force.force("group").deleteTemplate(svg);
    }
  });
});

function dragstarted(d) {
    if (!d3.event.active) force.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) force.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

</script>
